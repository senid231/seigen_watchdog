# Generated from lib/seigen_watchdog/monitor.rb with RBS::Inline

module SeigenWatchdog
  # Monitor class that checks limiters and invokes the killer when needed
  class Monitor
    @mutex: Thread::Mutex

    @running: bool

    @thread: Thread? | nil

    @time_killed: Float? | nil

    @last_check_time: Float? | nil

    @checks: Integer

    @before_kill: Proc?

    @on_exception: Proc?

    @logger: Logger?

    @limiters: Hash[Symbol, Limiters::Base]

    @killer: Killers::Base

    @check_interval: Numeric?

    # @rbs!
    #   attr_reader checks: Integer
    attr_reader checks: untyped

    # Interval in seconds between checks, nil to disable background thread
    # @rbs check_interval: Numeric?
    # The killer to invoke when a limit is exceeded
    # @rbs killer: Killers::Base
    # Hash of limiters to check
    # @rbs limiters: Hash[Symbol, Limiters::Base]
    # Optional logger for debugging
    # @rbs logger: Logger?
    # Optional callback when an exception occurs
    # @rbs on_exception: Proc?
    # Optional callback invoked before killing, receives exceeded limiter
    # @rbs before_kill: Proc?
    # @rbs return: void
    def initialize: (check_interval: Numeric?, killer: Killers::Base, limiters: Hash[Symbol, Limiters::Base], ?logger: Logger?, ?on_exception: Proc?, ?before_kill: Proc?) -> void

    # Performs a single check of all limiters
    # Returns true if any limiter exceeded and killer was invoked
    # @rbs return: bool
    def check_once: () -> bool

    # Returns the number of seconds since the last check
    # Seconds since last check, or nil if no check has been performed
    # @rbs return: Float?
    def seconds_after_last_check: () -> Float?

    # Returns true if the killer has been invoked
    # @rbs return: bool
    def killed?: () -> bool

    # Returns the number of seconds since the killer was invoked
    # Seconds since killer was invoked, or nil if killer has not been invoked
    # @rbs return: Float?
    def seconds_since_killed: () -> Float?

    # Stops the background thread if running
    # @rbs return: void
    def stop: () -> void

    # Checks if the background thread is running
    # Returns true if the background thread is running
    # @rbs return: bool
    def running?: () -> bool

    # Returns a limiter by name
    # @rbs name: Symbol | String
    # @rbs return: Limiters::Base
    def limiter: (Symbol | String name) -> Limiters::Base

    # Returns a hash of all limiters
    # Returns a new hash with the same keys and values
    # Modifications to the hash won't affect internal state, but limiter instances are shared
    # @rbs return: Hash[Symbol | String, Limiters::Base]
    def limiters: () -> Hash[Symbol | String, Limiters::Base]

    private

    # @rbs name: Symbol
    # @rbs limiter: Limiters::Base
    # @rbs return: void
    def perform_kill: (Symbol name, Limiters::Base limiter) -> void

    # @rbs name: Symbol
    # @rbs limiter: Limiters::Base
    # @rbs return: void
    def run_before_kill: (Symbol name, Limiters::Base limiter) -> void

    # @rbs return: void
    def increment_checks: () -> void

    # @rbs return: void
    def start_background_thread: () -> void

    # @rbs return: void
    def background_loop: () -> void

    # @rbs exception: StandardError
    # @rbs return: void
    def handle_exception: (StandardError exception) -> void

    # @rbs message: String
    # @rbs return: void
    def log_debug: (String message) -> void

    # @rbs message: String
    # @rbs return: void
    def log_info: (String message) -> void

    # @rbs message: String
    # @rbs return: void
    def log_error: (String message) -> void
  end
end
